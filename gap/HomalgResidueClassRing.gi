#############################################################################
##
##  HomalgResidueClassRing.gi   homalg package               Mohamed Barakat
##
##  Copyright 2007-2009 Mohamed Barakat, Universit√§t des Saarlandes
##
##  Implementation stuff for homalg residue class rings.
##
#############################################################################

##  <#GAPDoc Label="ResidueClassRingConstructor">
##  <ManSection>
##    <Oper Arg="R, ring_rel" Name="\/" Label="constructor for residue class rings"/>
##    <Returns>a &homalg; ring</Returns>
##    <Description>
##      This is the &homalg; constructor for residue class rings <A>R</A> <M>/ I</M>, where
##      <A>R</A> is a &homalg; ring and <M>I=</M><A>ring_rel</A> is the ideal of relations
##      generated by <A>ring_rel</A>. <A>ring_rel</A> might be:
##      <List>
##        <Item>a set of left resp. right relations on one generator</Item>
##        <Item>a list of ring elements of <A>R</A></Item>
##        <Item>a ring element of <A>R</A></Item>
##      </List>
##      For noncommutative rings: In the first case the left resp. right set of relations
##      should generate the ideal of relations <M>I</M> as left resp. right ideal generators,
##      and their involutions should generate <M>I</M> as right resp. left ideal generators.
##      If <A>ring_rel</A> is not a set of relations, a <E>left</E> set of relations is constructed. <P/>
##      The operation <C>SetRingProperties</C> is automatically invoked to set the ring properties.
##      <Example><![CDATA[
##  gap> ZZ := HomalgRingOfIntegers( );
##  <A homalg internal ring>
##  gap> Display( ZZ );
##  Z
##  gap> Z256 := ZZ / 2^8;
##  <A homalg internal ring>
##  gap> Display( Z256 );
##  Z/( 256 )
##  gap> Z2 := Z256 / 6;
##  <A homalg internal ring>
##  gap> Display( Z2 );
##  Z/( 2 )
##  ]]></Example>
##    </Description>
##  </ManSection>
##  <#/GAPDoc>
##
InstallMethod( \/,	## this operation is declared in the file HomalgRelations.gd
        "for homalg rings",
        [ IsHomalgRing, IsHomalgRelations ],
        
  function( R, ring_rel )
    local S, mat, rel, left, rel_old, mat_old, left_old, c;
    
    S := CallFuncList( CreateHomalgRing, R!.ConstructorArguments );
    
    mat := MatrixOfRelations( ring_rel );
    
    mat := mat * S;
    
    left := IsHomalgRelationsOfLeftModule( ring_rel );
    
    if left then
        if NrColumns( mat ) <> 1 then
            Error( "This is not a set of relations on one generator\n" );
        fi;
        rel := HomalgRelationsForLeftModule( mat );
    else
        if NrRows( mat ) <> 1 then
            Error( "This is not a set of relations on one generator\n" );
        fi;
        rel := HomalgRelationsForRightModule( mat );
    fi;
    
    ## merge the new relations with the relations of the ambient ring
    if HasRingRelations( R ) then
        SetAmbientRing( S, AmbientRing( R ) );
        rel_old := RingRelations( R );
        mat_old := MatrixOfRelations( rel_old );
        mat_old := mat_old * S;
        left_old := IsHomalgRelationsOfLeftModule( rel_old );
        if left_old <> left then
            Error( "the relations of the ambient ring and the given relations must both be either left or right relations\n" );
        fi;
        if left_old then
            rel_old := HomalgRelationsForLeftModule( mat_old );
        else
            rel_old := HomalgRelationsForRightModule( mat_old );
        fi;
        rel := BasisOfModule( UnionOfRelations( rel_old, rel ) );
    else
        SetAmbientRing( S, R );
    fi;
    
    SetRingRelations( S, rel );
    
    ## residue class rings of the integers
    if HasIsResidueClassRingOfTheIntegers( R ) and
       IsResidueClassRingOfTheIntegers( R ) then
        SetIsResidueClassRingOfTheIntegers( S, true );
        c := RingRelations( S );
        c := MatrixOfRelations( c );
        c := EntriesOfHomalgMatrix( c );
        if Length( c ) = 1 then
            c := c[1];
            if IsHomalgRingElement( c ) and
               IsInt( homalgPointer( c ) ) then
                c := homalgPointer( c );
            fi;
        fi;
        if IsInt( c ) then
            SetRingProperties( S, c );
        fi;
    fi;
    
    return S;
    
end );

##
InstallMethod( \/,
        "for homalg rings",
        [ IsHomalgRing, IsList ],
        
  function( R, ring_rel )
    
    if not ForAll( ring_rel, IsRingElement ) then
        TryNextMethod( );
    fi;
    
    return R / HomalgRelationsForLeftModule( HomalgMatrix( ring_rel, Length( ring_rel ), 1, R ) );
    
end );

##
InstallMethod( \/,
        "for homalg rings",
        [ IsHomalgRing, IsRingElement ],
        
  function( R, ring_rel )
    
    return R / [ ring_rel ];
    
end );

