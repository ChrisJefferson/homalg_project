#############################################################################
##
##  Tools.gi                    Modules package              Mohamed Barakat
##
##  Copyright 2009, Mohamed Barakat, Universit√§t des Saarlandes
##
##  Implementations of tool procedures.
##
#############################################################################

####################################
#
# methods for operations:
#
####################################

##  <#GAPDoc Label="Eliminate">
##  <ManSection>
##    <Oper Arg="rel, indets" Name="Eliminate"/>
##    <Returns>a &homalg; matrix</Returns>
##    <Description>
##      Eliminate the independents <A>indets</A> from the list of ring elements <A>rel</A>, i.e. compute a generating set
##      of the ideal defined as the intersection of the ideal generated by the entries of the list <A>rel</A>
##      with the subring generated by all indeterminates except those in <A>indets</A>.
##      by the list of indeterminates <A>indets</A>.
##    </Description>
##  </ManSection>
##  <#/GAPDoc>
##
InstallMethod( Eliminate,
        "for lists of ring elements",
        [ IsList, IsList ],
        
  function( rel, indets )
    local R, RP, elim;
    
    if rel = [ ] then
        Error( "first argument empty\n" );
    fi;
    
    R := HomalgRing( rel[1] );
    
    RP := homalgTable( R );
    
    if IsBound(RP!.Eliminate) then
        elim := RP!.Eliminate( rel, indets, R );	## the external object
        elim := HomalgMatrix( elim, R );
        SetNrColumns( elim, 1 );
        return elim;
    fi;
    
    if not IsHomalgInternalRingRep( R ) then
        Error( "could not find a procedure called Eliminate ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    TryNextMethod( );
    
end );

##
InstallMethod( Eliminate,
        "for lists of ring elements",
        [ IsList, IsHomalgRingElement ],
        
  function( rel, v )
    
    return Eliminate( rel, [ v ] );
    
end );

##
InstallMethod( AffineDimension,
        "for homalg matrices",
        [ IsHomalgMatrix ],
        
  function( M )
    local R, RP;
    
    if IsBound( M!.AffineDimension ) then
        return M!.AffineDimension;
    fi;
    
    R := HomalgRing( M );
    
    ## take care of zero matrices, especially of empty matrices
    if NrColumns( M ) = 0 then
        return -1;
    elif IsZero( M ) = 0 and HasKrullDimension( R ) then
        return KrullDimension( R );
    fi;
    
    RP := homalgTable( R );
    
    if IsBound(RP!.AffineDimension) then
        M!.AffineDimension := RP!.AffineDimension( M );
        return M!.AffineDimension;
    fi;
    
    if not IsHomalgInternalRingRep( R ) then
        Error( "could not find a procedure called AffineDimension ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    TryNextMethod( );
    
end );

##
InstallMethod( AffineDegree,
        "for homalg matrices",
        [ IsHomalgMatrix ],
        
  function( M )
    local R, RP;
    
    if IsBound( M!.AffineDegree ) then
        return M!.AffineDegree;
    fi;
    
    ## take care of zero matrices, especially of empty matrices
    if NrColumns( M ) = 0 then
        return 0;
    elif IsZero( M ) = 0 then
        return NrColumns( M );
    fi;
    
    R := HomalgRing( M );
    
    RP := homalgTable( R );
    
    if IsBound(RP!.AffineDegree) then
        M!.AffineDegree := RP!.AffineDegree( M );
        return M!.AffineDegree;
    fi;
    
    if not IsHomalgInternalRingRep( R ) then
        Error( "could not find a procedure called AffineDegree ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    TryNextMethod( );
    
end );

##
InstallMethod( ConstantTermOfHilbertPolynomial,
        "for homalg matrices",
        [ IsHomalgMatrix ],
        
  function( M )
    local R, RP;
    
    if IsBound( M!.ConstantTermOfHilbertPolynomial ) then
        return M!.ConstantTermOfHilbertPolynomial;
    fi;
    
    ## take care of zero matrices, especially of empty matrices
    if NrColumns( M ) = 0 then
        return 0;
    elif IsZero( M ) = 0 then
        return NrColumns( M );
    fi;
    
    R := HomalgRing( M );
    
    RP := homalgTable( R );
    
    if IsBound(RP!.ConstantTermOfHilbertPolynomial) then
        M!.ConstantTermOfHilbertPolynomial := RP!.ConstantTermOfHilbertPolynomial( M );
        return M!.ConstantTermOfHilbertPolynomial;
    fi;
    
    if not IsHomalgInternalRingRep( R ) then
        Error( "could not find a procedure called ConstantTermOfHilbertPolynomial ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    TryNextMethod( );
    
end );

##
InstallMethod( PrimaryDecompositionOp,
        "for homalg matrices",
        [ IsHomalgMatrix ],
        
  function( M )
    local R, RP;
    
    if IsBound( M!.PrimaryDecomposition ) then
        return M!.PrimaryDecomposition;
    fi;
    
    R := HomalgRing( M );
    
    RP := homalgTable( R );
    
    if IsBound(RP!.PrimaryDecomposition) then
        M!.PrimaryDecomposition := RP!.PrimaryDecomposition( M );
        return M!.PrimaryDecomposition;
    fi;
    
    if not IsHomalgInternalRingRep( R ) then
        Error( "could not find a procedure called PrimaryDecomposition ",
               "in the homalgTable of the non-internal ring\n" );
    fi;
    
    TryNextMethod( );
    
end );

