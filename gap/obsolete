##
## from change.log:
##
- added way to optionally ignore the logical subpackages
  (LRING, LIMAT, COLEM, LIMOD) by setting the global variable
  DoNotLoadLogicForHomalg to true (a warning will be issued)

##
## from read.g
##

## LogicForHomalg subpackages
if not ( IsBound( DoNotLoadLogicForHomalg ) and DoNotLoadLogicForHomalg = true ) then
    ReadPackage( "homalg", "gap/LIRNG.gi" );
    ReadPackage( "homalg", "gap/LIMAT.gi" );
    ReadPackage( "homalg", "gap/COLEM.gi" );
    ReadPackage( "homalg", "gap/LIMOD.gi" );
else
    Print( "WARNING: the subpackage LogicForHomalg was not loaded!\n" );
fi;



##
## from: HomalgGenerators.gi
##

##
InstallMethod( BasisOfModule,
        "for sets of generators of homalg modules",
        [ IsGeneratorsOfFinitelyGeneratedModuleRep and IsHomalgGeneratorsOfLeftModule ],
        
  function( gen )
    local bas;
    
    if not IsBound( gen!.BasisOfModule ) then
        gen!.BasisOfModule := BasisOfRows( MatrixOfGenerators( gen ) );
        SetCanBeUsedToDecideZeroEffectively( gen, false );
    fi;
    
    bas := HomalgGeneratorsForLeftModule( gen!.BasisOfModule, HomalgRing( gen ) );
    
    SetCanBeUsedToDecideZeroEffectively( bas, true );
    
    return HomalgRelationsForLeftModule( MatrixOfGenerators( bas ) );	## FIXME: written for \/ in Modules.gi (should become obsolete when DefectOfExactness arrives)
    
end );

##
InstallMethod( BasisOfModule,
        "for sets of generators of homalg modules",
        [ IsGeneratorsOfFinitelyGeneratedModuleRep and IsHomalgGeneratorsOfRightModule ],
        
  function( gen )
    local bas;
    
    if not IsBound( gen!.BasisOfModule ) then
        gen!.BasisOfModule := BasisOfColumns( MatrixOfGenerators( gen ) );
        SetCanBeUsedToDecideZeroEffectively( gen, false );
    fi;
    
    bas := HomalgGeneratorsForRightModule( gen!.BasisOfModule, HomalgRing( gen ) );
    
    SetCanBeUsedToDecideZeroEffectively( bas, true );
        
    return HomalgRelationsForRightModule( MatrixOfGenerators( bas ) );	## FIXME: written for \/ in Modules.gi (should become obsolete when DefectOfExactness arrives)
    
end );

##
## from: Modules.gi
##

##
InstallMethod( \/,				### defines: SubfactorModule (incomplete)
        "for homalg generators",
        [ IsGeneratorsOfFinitelyGeneratedModuleRep, IsGeneratorsOfFinitelyGeneratedModuleRep ],
        
  function( gen1, gen2 )
    local R, B, N, S;
    
    R := HomalgRing( gen1 );
    
    # basis of gen2
    B := BasisOfModule( gen2 );
    
    # normal forms of generators of gen1 with respect to B
    N := DecideZero( gen1, B );
    
    if IsHomalgGeneratorsOfLeftModule( gen1 ) then
        N := HomalgGeneratorsForLeftModule( N );
    else
        N := HomalgGeneratorsForRightModule( N );
    fi;
    
    # get a better basis for N
    N := GetRidOfObsoleteGenerators( N );
    
    # compute the syzygies module of N modulo B
    S := SyzygiesGenerators( N, B );
    
    return Presentation( S );
    
end );

## was part of _Functor_Cokernel_OnObjects

    if IsZero( phi ) then
        coker := Range( phi );
        epi := TheIdentityMorphism( coker );
        if not IsBound( coker!.NaturalEmbedding ) then
            coker!.NaturalEmbedding := epi;
        fi;
        SetCokernelEpi( phi, epi );
        return coker;	## this is crucial for IsIdenticalObj( Ext( 0, M, N ), Hom( M, N ) ) = true (we hope there is no need to set further attributes as below)
    fi;
    
## from HomalgComplex
##
InstallMethod( ViewObj,
        "for homalg complexes",
        [ IsComplexOfFinitelyPresentedObjectsRep and IsAcyclic ],
        
  function( o )
    local l, degrees;
    
    Print( "<An acyclic complex consisting of " );
    
    degrees := ObjectDegreesOfComplex( o );
    
    l := Length( degrees );
    
    if l = 1 then
        Print( "a single" );
    else
        Print( l );
    fi;
    
    if IsHomalgLeftObjectOrMorphismOfLeftObjects( o ) then
        Print( " left" );
    else
        Print( " right" );
    fi;
    
    if IsHomalgModule( CertainObject( o, degrees[1] ) ) then
        Print( " module" );
        if l > 1 then
            Print( "s" );
        fi;
    else
        if IsComplexOfFinitelyPresentedObjectsRep( CertainObject( o, degrees[1] ) ) then
            Print( " complex" );
        else
            Print( " cocomplex" );
        fi;
        if l > 1 then
            Print( "es" );
        fi;
    fi;
    
    Print( " at degree" );
    
    if l = 1 then
        Print( " ", degrees[1] );
    else
        Print( "s ", degrees );
    fi;
    
    Print( ">" );
    
end );

##
InstallMethod( ViewObj,
        "for homalg complexes",
        [ IsCocomplexOfFinitelyPresentedObjectsRep and IsAcyclic ],
        
  function( o )
    local l, degrees;
    
    Print( "<An acyclic cocomplex consisting of " );
    
    degrees := ObjectDegreesOfComplex( o );
    
    l := Length( degrees );
    
    if l = 1 then
        Print( "a single" );
    else
        Print( l );
    fi;
    
    if IsHomalgLeftObjectOrMorphismOfLeftObjects( o ) then
        Print( " left" );
    else
        Print( " right" );
    fi;
    
    if IsHomalgModule( CertainObject( o, degrees[1] ) ) then
        Print( " module" );
        if l > 1 then
            Print( "s" );
        fi;
    else
        if IsComplexOfFinitelyPresentedObjectsRep( CertainObject( o, degrees[1] ) ) then
            Print( " complex" );
        else
            Print( " cocomplex" );
        fi;
        if l > 1 then
            Print( "es" );
        fi;
    fi;
    
    Print( " at cohomology degree" );
    
    if l = 1 then
        Print( " ", degrees[1] );
    else
        Print( "s ", degrees );
    fi;
    
    Print( ">" );
    
end );

## from HomalgMatrix

    internal := false;
    
    if IsMatrix( M ) then
        internal := true;
    elif IsList( M ) and ForAll( M, a -> a = [ ] ) then	## this must remain above the next ifs
        internal := true;
    elif IsBound( HOMALG.OtherInternalMatrixTypes ) then
        for ar in HOMALG.OtherInternalMatrixTypes do
            internal := internal or ar( M );
            if internal then
                break;
            fi;
        od;
    fi;
    
## from BasicFunctors.gi

## install Cokernel for image squares (this should be installed automatically in the future)
InstallOtherMethod( Cokernel,
        "for homalg image squares",
        [ IsHomalgChainMap and IsImageSquare ],
  function( sq )
    local d, dS, dT, phi, muS, muT;
    
    d := DegreesOfChainMap( sq )[1];
    
    dS := LowestDegreeMorphismInComplex( Source( sq ) );
    dT := LowestDegreeMorphismInComplex( Range( sq ) );
    
    phi := CertainMorphism( sq, d );
    
    muS := NaturalEmbedding( Cokernel( dS ) );
    muT := NaturalEmbedding( Cokernel( dT ) );
    
    return CompleteImageSquare( muS, phi, muT );
    
end );

## install Kernel for kernel squares (this should be installed automatically in the future)
InstallOtherMethod( Kernel,
        "for homalg kernel squares",
        [ IsHomalgChainMap and IsKernelSquare ],
  function( sq )
    local d, dS, dT, phi, muS, muT;
    
    d := DegreesOfChainMap( sq )[1];
    
    dS := LowestDegreeMorphismInComplex( Source( sq ) );
    dT := LowestDegreeMorphismInComplex( Range( sq ) );
    
    phi := CertainMorphism( sq, d );
    
    muS := NaturalEmbedding( Kernel( dS ) );
    muT := NaturalEmbedding( Kernel( dT ) );
    
    return CompleteImageSquare( muS, phi, muT );
    
end );

## install DefectOfExactness for Lambek pair of squares (this should be installed automatically in the future)
InstallOtherMethod( DefectOfExactness,
        "for homalg Lambek pair of squares",
        [ IsHomalgChainMap and IsLambekPairOfSquares ],
  function( sq )
    local d, dS, dT, phi, muS, muT;
    
    d := DegreesOfChainMap( sq )[1];
    
    dS := AsATwoSequence( Source( sq ) );
    dT := AsATwoSequence( Range( sq ) );
    
    phi := CertainMorphism( sq, d );
    
    muS := NaturalEmbedding( DefectOfExactness( dS ) );
    muT := NaturalEmbedding( DefectOfExactness( dT ) );
    
    return CompleteImageSquare( muS, phi, muT );
    
end );

## install KernelEmb for kernel squares (this should be installed automatically in the future)
InstallOtherMethod( KernelEmb,
        "for homalg kernel squares",
        [ IsHomalgChainMap and IsKernelSquare ],
  function( sq )
    local d, dS, dT, phi, muS, muT, kappa;
    
    d := DegreesOfChainMap( sq )[1];
    
    dS := LowestDegreeMorphismInComplex( Source( sq ) );
    dT := LowestDegreeMorphismInComplex( Range( sq ) );
    
    phi := CertainMorphism( sq, d );
    
    muS := KernelEmb( dS );
    muT := KernelEmb( dT );
    
    kappa := CompleteImageSquare( muS, phi, muT );
    
    if IsComplexOfFinitelyPresentedObjectsRep( Source( sq ) ) then
        muS := HomalgComplex( muS, d + 1 );
        muT := HomalgComplex( muT, d + 1 );
        kappa := HomalgChainMap( kappa, muS, muT, d + 1 );
    else
        muS := HomalgCocomplex( muS, d - 1 );
        muT := HomalgCocomplex( muT, d - 1 );
        kappa := HomalgChainMap( kappa, muS, muT, d - 1 );
    fi;
    
    return kappa;
    
end );

## from LIMOD
##
InstallImmediateMethod( ElementaryDivisorsOfLeftModule,
        IsFinitelyPresentedModuleRep and IsZeroModule and HasLeftActingDomain, 0, ## FIXME: remove HasLeftActingDomain
        
  function( M )
    local R;
    
    R := HomalgRing( M );
    
    if HasIsLeftPrincipalIdealRing( R ) and IsLeftPrincipalIdealRing( R ) then
        return [ ];
    fi;
    
    TryNextMethod( );
    
end );

##
InstallImmediateMethod( ElementaryDivisorsOfLeftModule,
        IsFinitelyPresentedModuleRep and IsFreeModule and HasLeftActingDomain, 0, ## FIXME: remove HasLeftActingDomain
        
  function( M )
    local R;
    
    R := HomalgRing( M );
    
    if HasIsLeftPrincipalIdealRing( R ) and IsLeftPrincipalIdealRing( R ) then
        return ListWithIdenticalEntries( NrGenerators( M ), Zero( R ) );
    fi;
    
    TryNextMethod( );
    
end );

## from HomalgMap
##
InstallMethod( \*,
        "of two homalg maps",
        [ IsRingElement, IsMapOfFinitelyGeneratedModulesRep ], 1001, ## it could otherwise run into the method ``PROD: negative integer * additive element with inverse'', value: 24
        
  function( a, phi )
    local a_phi;
    
    a_phi := HomalgMap( a * MatrixOfMap( phi ), Source( phi ), Range( phi ) );
    
    if IsUnit( HomalgRing( phi ), a ) then
        if HasIsIsomorphism( phi ) and IsIsomorphism( phi ) then
            SetIsIsomorphism( a_phi, true );
        else
            if HasIsSplitMonomorphism( phi ) and IsSplitMonomorphism( phi ) then
                SetIsSplitMonomorphism( a_phi, true );
            elif HasIsMonomorphism( phi ) and IsMonomorphism( phi ) then
                SetIsMonomorphism( a_phi, true );
            fi;
            
            if HasIsSplitEpimorphism( phi ) and IsSplitEpimorphism( phi ) then
                SetIsSplitEpimorphism( a_phi, true );
            elif HasIsEpimorphism( phi ) and IsEpimorphism( phi ) then
                SetIsEpimorphism( a_phi, true );
            elif HasIsMorphism( phi ) and IsMorphism( phi ) then
                SetIsMorphism( a_phi, true );
            fi;
        fi;
    elif HasIsMorphism( phi ) and IsMorphism( phi ) then
        SetIsMorphism( a_phi, true );
    fi;
    
    return a_phi;
    
end );

##
InstallMethod( \+,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep, IsMapOfFinitelyGeneratedModulesRep ],
        
  function( phi1, phi2 )
    local phi;
    
    if not AreComparableMorphisms( phi1, phi2 ) then
        return Error( "the two maps are not comparable" );
    fi;
    
    phi := HomalgMap( MatrixOfMap( phi1 ) + MatrixOfMap( phi2 ), Source( phi1 ), Range( phi1 ) );
    
    if HasIsMorphism( phi1 ) and IsMorphism( phi1 ) and
       HasIsMorphism( phi2 ) and IsMorphism( phi2 ) then
        SetIsMorphism( phi, true );
    fi;
    
    return phi;
    
end );

##
InstallMethod( \-,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep, IsMapOfFinitelyGeneratedModulesRep ],
        
  function( phi1, phi2 )
    local phi;
    
    if not AreComparableMorphisms( phi1, phi2 ) then
        return Error( "the two maps are not comparable" );
    fi;
    
    phi := HomalgMap( MatrixOfMap( phi1 ) - MatrixOfMap( phi2 ), Source( phi1 ), Range( phi1 ) );
    
    if HasIsMorphism( phi1 ) and IsMorphism( phi1 ) and
       HasIsMorphism( phi2 ) and IsMorphism( phi2 ) then
        SetIsMorphism( phi, true );
    fi;
    
    return phi;
    
end );

## from change log
- the attribute Eval of an internal homalg matrix is now not directly
  a gap matrix (i.e. IsMatrix) but a hull of it:
  this allows changing their entries!!!
  for this the following was added:
  . a GAP-category IsInternalMatrixHull
  . a simple constructor called homalgInternalMatrixHull
  . a method for \=
  . a method for scalar multiplication \*
  . a method for addition \+
  . a method for AdditiveInverseMutable
  . a method for substraction \-
  . a method for composition \*
  . a simple view method
  . a display method that simply displays the contained matrix
- adapted the code to use Eval( M )!.matrix instead of Eval( M )
  and to return homalgInternalMatrixHull( IsMatrix )
- added the matrix "property" IsMutableMatrix which is only set to true for
  IsInitialMatrix and IsInitialIdentityMatrix (otherwise not set)
  (programmers should reset it when they finished changing the matrix)
- declared and installed SetEntryOfHomalgMatrix for internal matrices
  together with methods that issue the following error if the property
  IsMutableMatrix is not set (to true):
  Error( "the homalg matrix is write-protected\n" );
- declared and installed AddToEntryOfHomalgMatrix together with a method
  that issues the "write-protected"-error if the matrix is not set
  IsMutableMatrix (to true)
- GetEntryOfHomalgMatrixAsString is now based on GetEntryOfHomalgMatrix
- if the input of HomalgMatrix is an IsMatrix a shallow copy of it is made
- HomalgMatrix now additionally accepts a hull of an internal matrix as its
  first argument
- fixed loading GaussForHomalg in HomalgFieldOfRationals
- fixed evaluating internal initial (zero) matrices
- use ObjectifyWithAttributes more consequently in
  . HomalgMatrix
  . HomalgZeroMatrix
  . HomalgIdentityMatrix
  . HomalgInitialMatrix
  . HomalgInitialIdentityMatrix
  . HomalgVoidMatrix
