##
## from change.log:
##
- added way to optionally ignore the logical subpackages
  (LRING, LIMAT, COLEM, LIMOD) by setting the global variable
  DoNotLoadLogicForHomalg to true (a warning will be issued)

##
## from read.g
##

## LogicForHomalg subpackages
if not ( IsBound( DoNotLoadLogicForHomalg ) and DoNotLoadLogicForHomalg = true ) then
    ReadPackage( "homalg", "gap/LIRNG.gi" );
    ReadPackage( "homalg", "gap/LIMAT.gi" );
    ReadPackage( "homalg", "gap/COLEM.gi" );
    ReadPackage( "homalg", "gap/LIMOD.gi" );
else
    Print( "WARNING: the subpackage LogicForHomalg was not loaded!\n" );
fi;



##
## from: HomalgGenerators.gi
##

##
InstallMethod( BasisOfModule,
        "for sets of generators of homalg modules",
        [ IsGeneratorsOfFinitelyGeneratedModuleRep and IsHomalgGeneratorsOfLeftModule ],
        
  function( gen )
    local bas;
    
    if not IsBound( gen!.BasisOfModule ) then
        gen!.BasisOfModule := BasisOfRows( MatrixOfGenerators( gen ) );
        SetCanBeUsedToDecideZeroEffectively( gen, false );
    fi;
    
    bas := HomalgGeneratorsForLeftModule( gen!.BasisOfModule, HomalgRing( gen ) );
    
    SetCanBeUsedToDecideZeroEffectively( bas, true );
    
    return HomalgRelationsForLeftModule( MatrixOfGenerators( bas ) );	## FIXME: written for \/ in Modules.gi (should become obsolete when DefectOfExactness arrives)
    
end );

##
InstallMethod( BasisOfModule,
        "for sets of generators of homalg modules",
        [ IsGeneratorsOfFinitelyGeneratedModuleRep and IsHomalgGeneratorsOfRightModule ],
        
  function( gen )
    local bas;
    
    if not IsBound( gen!.BasisOfModule ) then
        gen!.BasisOfModule := BasisOfColumns( MatrixOfGenerators( gen ) );
        SetCanBeUsedToDecideZeroEffectively( gen, false );
    fi;
    
    bas := HomalgGeneratorsForRightModule( gen!.BasisOfModule, HomalgRing( gen ) );
    
    SetCanBeUsedToDecideZeroEffectively( bas, true );
        
    return HomalgRelationsForRightModule( MatrixOfGenerators( bas ) );	## FIXME: written for \/ in Modules.gi (should become obsolete when DefectOfExactness arrives)
    
end );

##
## from: Modules.gi
##

##
InstallMethod( \/,				### defines: SubfactorModule (incomplete)
        "for homalg generators",
        [ IsGeneratorsOfFinitelyGeneratedModuleRep, IsGeneratorsOfFinitelyGeneratedModuleRep ],
        
  function( gen1, gen2 )
    local R, B, N, S;
    
    R := HomalgRing( gen1 );
    
    # basis of gen2
    B := BasisOfModule( gen2 );
    
    # normal forms of generators of gen1 with respect to B
    N := DecideZero( gen1, B );
    
    if IsHomalgGeneratorsOfLeftModule( gen1 ) then
        N := HomalgGeneratorsForLeftModule( N );
    else
        N := HomalgGeneratorsForRightModule( N );
    fi;
    
    # get a better basis for N
    N := GetRidOfObsoleteGenerators( N );
    
    # compute the syzygies module of N modulo B
    S := SyzygiesGenerators( N, B );
    
    return Presentation( S );
    
end );

## was part of _Functor_Cokernel_OnObjects

    if IsZero( phi ) then
        coker := Range( phi );
        epi := TheIdentityMorphism( coker );
        if not IsBound( coker!.NaturalGeneralizedEmbedding ) then
            coker!.NaturalGeneralizedEmbedding := epi;
        fi;
        SetCokernelEpi( phi, epi );
        return coker;	## this is crucial for IsIdenticalObj( Ext( 0, M, N ), Hom( M, N ) ) = true (we hope there is no need to set further attributes as below)
    fi;
    
## from HomalgComplex
##
InstallMethod( ViewObj,
        "for homalg complexes",
        [ IsComplexOfFinitelyPresentedObjectsRep and IsAcyclic ],
        
  function( o )
    local l, degrees;
    
    Print( "<An acyclic complex consisting of " );
    
    degrees := ObjectDegreesOfComplex( o );
    
    l := Length( degrees );
    
    if l = 1 then
        Print( "a single" );
    else
        Print( l );
    fi;
    
    if IsHomalgLeftObjectOrMorphismOfLeftObjects( o ) then
        Print( " left" );
    else
        Print( " right" );
    fi;
    
    if IsHomalgModule( CertainObject( o, degrees[1] ) ) then
        Print( " module" );
        if l > 1 then
            Print( "s" );
        fi;
    else
        if IsComplexOfFinitelyPresentedObjectsRep( CertainObject( o, degrees[1] ) ) then
            Print( " complex" );
        else
            Print( " cocomplex" );
        fi;
        if l > 1 then
            Print( "es" );
        fi;
    fi;
    
    Print( " at degree" );
    
    if l = 1 then
        Print( " ", degrees[1] );
    else
        Print( "s ", degrees );
    fi;
    
    Print( ">" );
    
end );

##
InstallMethod( ViewObj,
        "for homalg complexes",
        [ IsCocomplexOfFinitelyPresentedObjectsRep and IsAcyclic ],
        
  function( o )
    local l, degrees;
    
    Print( "<An acyclic cocomplex consisting of " );
    
    degrees := ObjectDegreesOfComplex( o );
    
    l := Length( degrees );
    
    if l = 1 then
        Print( "a single" );
    else
        Print( l );
    fi;
    
    if IsHomalgLeftObjectOrMorphismOfLeftObjects( o ) then
        Print( " left" );
    else
        Print( " right" );
    fi;
    
    if IsHomalgModule( CertainObject( o, degrees[1] ) ) then
        Print( " module" );
        if l > 1 then
            Print( "s" );
        fi;
    else
        if IsComplexOfFinitelyPresentedObjectsRep( CertainObject( o, degrees[1] ) ) then
            Print( " complex" );
        else
            Print( " cocomplex" );
        fi;
        if l > 1 then
            Print( "es" );
        fi;
    fi;
    
    Print( " at cohomology degree" );
    
    if l = 1 then
        Print( " ", degrees[1] );
    else
        Print( "s ", degrees );
    fi;
    
    Print( ">" );
    
end );

## from HomalgMatrix

    internal := false;
    
    if IsMatrix( M ) then
        internal := true;
    elif IsList( M ) and ForAll( M, a -> a = [ ] ) then	## this must remain above the next ifs
        internal := true;
    elif IsBound( HOMALG.OtherInternalMatrixTypes ) then
        for ar in HOMALG.OtherInternalMatrixTypes do
            internal := internal or ar( M );
            if internal then
                break;
            fi;
        od;
    fi;
    
## from BasicFunctors.gi

## install Cokernel for image squares (this should be installed automatically in the future)
InstallOtherMethod( Cokernel,
        "for homalg image squares",
        [ IsHomalgChainMap and IsImageSquare ],
  function( sq )
    local d, dS, dT, phi, muS, muT;
    
    d := DegreesOfChainMap( sq )[1];
    
    dS := LowestDegreeMorphism( Source( sq ) );
    dT := LowestDegreeMorphism( Range( sq ) );
    
    phi := CertainMorphism( sq, d );
    
    muS := NaturalGeneralizedEmbedding( Cokernel( dS ) );
    muT := NaturalGeneralizedEmbedding( Cokernel( dT ) );
    
    return CompleteImageSquare( muS, phi, muT );
    
end );

## install Kernel for kernel squares (this should be installed automatically in the future)
InstallOtherMethod( Kernel,
        "for homalg kernel squares",
        [ IsHomalgChainMap and IsKernelSquare ],
  function( sq )
    local d, dS, dT, phi, muS, muT;
    
    d := DegreesOfChainMap( sq )[1];
    
    dS := LowestDegreeMorphism( Source( sq ) );
    dT := LowestDegreeMorphism( Range( sq ) );
    
    phi := CertainMorphism( sq, d );
    
    muS := NaturalGeneralizedEmbedding( Kernel( dS ) );
    muT := NaturalGeneralizedEmbedding( Kernel( dT ) );
    
    return CompleteImageSquare( muS, phi, muT );
    
end );

## install DefectOfExactness for Lambek pair of squares (this should be installed automatically in the future)
InstallOtherMethod( DefectOfExactness,
        "for homalg Lambek pair of squares",
        [ IsHomalgChainMap and IsLambekPairOfSquares ],
  function( sq )
    local d, dS, dT, phi, muS, muT;
    
    d := DegreesOfChainMap( sq )[1];
    
    dS := AsATwoSequence( Source( sq ) );
    dT := AsATwoSequence( Range( sq ) );
    
    phi := CertainMorphism( sq, d );
    
    muS := NaturalGeneralizedEmbedding( DefectOfExactness( dS ) );
    muT := NaturalGeneralizedEmbedding( DefectOfExactness( dT ) );
    
    return CompleteImageSquare( muS, phi, muT );
    
end );

## install KernelEmb for kernel squares (this should be installed automatically in the future)
InstallOtherMethod( KernelEmb,
        "for homalg kernel squares",
        [ IsHomalgChainMap and IsKernelSquare ],
  function( sq )
    local d, dS, dT, phi, muS, muT, kappa;
    
    d := DegreesOfChainMap( sq )[1];
    
    dS := LowestDegreeMorphism( Source( sq ) );
    dT := LowestDegreeMorphism( Range( sq ) );
    
    phi := CertainMorphism( sq, d );
    
    muS := KernelEmb( dS );
    muT := KernelEmb( dT );
    
    kappa := CompleteImageSquare( muS, phi, muT );
    
    if IsComplexOfFinitelyPresentedObjectsRep( Source( sq ) ) then
        muS := HomalgComplex( muS, d + 1 );
        muT := HomalgComplex( muT, d + 1 );
        kappa := HomalgChainMap( kappa, muS, muT, d + 1 );
    else
        muS := HomalgCocomplex( muS, d - 1 );
        muT := HomalgCocomplex( muT, d - 1 );
        kappa := HomalgChainMap( kappa, muS, muT, d - 1 );
    fi;
    
    return kappa;
    
end );

## from LIMOD
##
InstallImmediateMethod( ElementaryDivisorsOfLeftModule,
        IsFinitelyPresentedModuleRep and IsZeroModule and HasLeftActingDomain, 0, ## FIXME: remove HasLeftActingDomain
        
  function( M )
    local R;
    
    R := HomalgRing( M );
    
    if HasIsLeftPrincipalIdealRing( R ) and IsLeftPrincipalIdealRing( R ) then
        return [ ];
    fi;
    
    TryNextMethod( );
    
end );

##
InstallImmediateMethod( ElementaryDivisorsOfLeftModule,
        IsFinitelyPresentedModuleRep and IsFreeModule and HasLeftActingDomain, 0, ## FIXME: remove HasLeftActingDomain
        
  function( M )
    local R;
    
    R := HomalgRing( M );
    
    if HasIsLeftPrincipalIdealRing( R ) and IsLeftPrincipalIdealRing( R ) then
        return ListWithIdenticalEntries( NrGenerators( M ), Zero( R ) );
    fi;
    
    TryNextMethod( );
    
end );

## from HomalgMap
##
InstallMethod( \*,
        "of two homalg maps",
        [ IsRingElement, IsMapOfFinitelyGeneratedModulesRep ], 1001, ## it could otherwise run into the method ``PROD: negative integer * additive element with inverse'', value: 24
        
  function( a, phi )
    local a_phi;
    
    a_phi := HomalgMap( a * MatrixOfMap( phi ), Source( phi ), Range( phi ) );
    
    if IsUnit( HomalgRing( phi ), a ) then
        if HasIsIsomorphism( phi ) and IsIsomorphism( phi ) then
            SetIsIsomorphism( a_phi, true );
        else
            if HasIsSplitMonomorphism( phi ) and IsSplitMonomorphism( phi ) then
                SetIsSplitMonomorphism( a_phi, true );
            elif HasIsMonomorphism( phi ) and IsMonomorphism( phi ) then
                SetIsMonomorphism( a_phi, true );
            fi;
            
            if HasIsSplitEpimorphism( phi ) and IsSplitEpimorphism( phi ) then
                SetIsSplitEpimorphism( a_phi, true );
            elif HasIsEpimorphism( phi ) and IsEpimorphism( phi ) then
                SetIsEpimorphism( a_phi, true );
            elif HasIsMorphism( phi ) and IsMorphism( phi ) then
                SetIsMorphism( a_phi, true );
            fi;
        fi;
    elif HasIsMorphism( phi ) and IsMorphism( phi ) then
        SetIsMorphism( a_phi, true );
    fi;
    
    return a_phi;
    
end );

##
InstallMethod( \+,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep, IsMapOfFinitelyGeneratedModulesRep ],
        
  function( phi1, phi2 )
    local phi;
    
    if not AreComparableMorphisms( phi1, phi2 ) then
        return Error( "the two maps are not comparable" );
    fi;
    
    phi := HomalgMap( MatrixOfMap( phi1 ) + MatrixOfMap( phi2 ), Source( phi1 ), Range( phi1 ) );
    
    if HasIsMorphism( phi1 ) and IsMorphism( phi1 ) and
       HasIsMorphism( phi2 ) and IsMorphism( phi2 ) then
        SetIsMorphism( phi, true );
    fi;
    
    return phi;
    
end );

##
InstallMethod( \-,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep, IsMapOfFinitelyGeneratedModulesRep ],
        
  function( phi1, phi2 )
    local phi;
    
    if not AreComparableMorphisms( phi1, phi2 ) then
        return Error( "the two maps are not comparable" );
    fi;
    
    phi := HomalgMap( MatrixOfMap( phi1 ) - MatrixOfMap( phi2 ), Source( phi1 ), Range( phi1 ) );
    
    if HasIsMorphism( phi1 ) and IsMorphism( phi1 ) and
       HasIsMorphism( phi2 ) and IsMorphism( phi2 ) then
        SetIsMorphism( phi, true );
    fi;
    
    return phi;
    
end );

## from change log
- the attribute Eval of an internal homalg matrix is now not directly
  a gap matrix (i.e. IsMatrix) but a hull of it:
  this allows changing their entries!!!
  for this the following was added:
  . a GAP-category IsInternalMatrixHull
  . a simple constructor called homalgInternalMatrixHull
  . a method for \=
  . a method for scalar multiplication \*
  . a method for addition \+
  . a method for AdditiveInverseMutable
  . a method for substraction \-
  . a method for composition \*
  . a simple view method
  . a display method that simply displays the contained matrix
- adapted the code to use Eval( M )!.matrix instead of Eval( M )
  and to return homalgInternalMatrixHull( IsMatrix )
- added the matrix "property" IsMutableMatrix which is only set to true for
  IsInitialMatrix and IsInitialIdentityMatrix (otherwise not set)
  (programmers should reset it when they finished changing the matrix)
- declared and installed SetEntryOfHomalgMatrix for internal matrices
  together with methods that issue the following error if the property
  IsMutableMatrix is not set (to true):
  Error( "the homalg matrix is write-protected\n" );
- declared and installed AddToEntryOfHomalgMatrix together with a method
  that issues the "write-protected"-error if the matrix is not set
  IsMutableMatrix (to true)
- GetEntryOfHomalgMatrixAsString is now based on GetEntryOfHomalgMatrix
- if the input of HomalgMatrix is an IsMatrix a shallow copy of it is made
- HomalgMatrix now additionally accepts a hull of an internal matrix as its
  first argument
- fixed loading GaussForHomalg in HomalgFieldOfRationals
- fixed evaluating internal initial (zero) matrices
- use ObjectifyWithAttributes more consequently in
  . HomalgMatrix
  . HomalgZeroMatrix
  . HomalgIdentityMatrix
  . HomalgInitialMatrix
  . HomalgInitialIdentityMatrix
  . HomalgVoidMatrix
## from HomalgMatrix.gi/gd

DeclareOperation( "AddToEntryOfHomalgMatrix",
        [ IsHomalgMatrix, IsInt, IsInt, IsString, IsHomalgRing ] );

DeclareOperation( "AddToEntryOfHomalgMatrix",
        [ IsHomalgMatrix, IsInt, IsInt, IsString ] );


##
InstallMethod( AddToEntryOfHomalgMatrix,
        "for homalg matrices",
        [ IsHomalgMatrix and IsMutableMatrix, IsInt, IsInt, IsString, IsHomalgInternalRingRep ],
        
  function( M, r, c, s, R )
    
    AddToEntryOfHomalgMatrix( M, r, c, One( R ) * EvalString( s ), R );
    
end );

##
InstallMethod( AddToEntryOfHomalgMatrix,
        "for homalg matrices",
        [ IsHomalgMatrix, IsInt, IsInt, IsString ],
        
  function( M, r, c, s )
    
    Error( "the homalg matrix is write-protected\n" );
    
end );

##
InstallMethod( AddToEntryOfHomalgMatrix,
        "for homalg matrices",
        [ IsHomalgMatrix and IsMutableMatrix, IsInt, IsInt, IsString ],
        
  function( M, r, c, s )
    
    AddToEntryOfHomalgMatrix( M, r, c, s, HomalgRing( M ) );
    
end );

## from HomalgBicomplex.gi

##
DeclareOperation( "ObjectOfTotalComplex",
        [ IsHomalgBicomplex, IsInt ] );

##
InstallMethod( ObjectOfTotalComplex,
        "for homalg bicomplexes",
        [ IsHomalgBicomplex, IsInt ],
        
  function( B, n )
    local bidegrees, tot_n, pq, sum, l, summand, embeddings, i, emb_summand;
    
    bidegrees := BidegreesOfObjectOfTotalComplex( B, n );
    
    if bidegrees = [ ] then
        return fail;
    fi;
    
    tot_n := [ ];
    
    for pq in bidegrees do
        Add( tot_n, CertainObject( B, pq ) );
    od;
    
    sum := Sum( tot_n );
    
    l := Length( tot_n );
    
    if l > 1 then
        summand := sum;
        embeddings := rec( );
        embeddings.(String(bidegrees[l])) := DirectSumEmbs( summand )[2];
        for i in [ 1 .. l - 1 ] do
            emb_summand := DirectSumEmbs( summand )[2];
            summand := Genesis( summand )!.arguments_of_functor[1];
            embeddings.(String(bidegrees[l - i])) := PreCompose( DirectSumEmbs( summand )[2], emb_summand );
        od;
        sum!.EmbeddingsInObjectOfTotalComplex := embeddings;
    fi;
    
    return sum;
    
end );

## from LIMAT.gi

##
InstallTrueMethod( IsReducedModuloRingRelations, IsHomalgMatrix and IsZero );

##
InstallTrueMethod( IsZero, IsHomalgMatrix and IsEmptyMatrix );

##
InstallTrueMethod( IsPermutationMatrix, IsHomalgMatrix and IsIdentityMatrix );

##
InstallTrueMethod( IsPermutationMatrix, IsHomalgMatrix and IsSubidentityMatrix and IsInvertibleMatrix );

##
InstallTrueMethod( IsInvertibleMatrix, IsHomalgMatrix and IsPermutationMatrix );

##
InstallTrueMethod( IsSubidentityMatrix, IsHomalgMatrix and IsPermutationMatrix );

##
InstallTrueMethod( IsSubidentityMatrix, IsHomalgMatrix and IsEmptyMatrix );

##
InstallTrueMethod( IsLeftInvertibleMatrix, IsHomalgMatrix and IsPermutationMatrix );

##
InstallTrueMethod( IsRightInvertibleMatrix, IsHomalgMatrix and IsPermutationMatrix );

## a split injective morphism (of free modules) is injective
InstallTrueMethod( IsLeftRegularMatrix, IsHomalgMatrix and IsRightInvertibleMatrix );

##
InstallTrueMethod( IsRightRegularMatrix, IsHomalgMatrix and IsLeftInvertibleMatrix );

## an isomorphism is split injective
InstallTrueMethod( IsRightInvertibleMatrix, IsHomalgMatrix and IsInvertibleMatrix );

## an isomorphism is split surjective
InstallTrueMethod( IsLeftInvertibleMatrix, IsHomalgMatrix and IsInvertibleMatrix );

## a split surjective and split injective morphism (of free modules) is an isomorphism
InstallTrueMethod( IsInvertibleMatrix, IsHomalgMatrix and IsLeftInvertibleMatrix and IsRightInvertibleMatrix );

##
InstallTrueMethod( IsUpperTriangularMatrix, IsHomalgMatrix and IsDiagonalMatrix );

##
InstallTrueMethod( IsLowerTriangularMatrix, IsHomalgMatrix and IsDiagonalMatrix );

##
InstallTrueMethod( IsUpperTriangularMatrix, IsHomalgMatrix and IsStrictUpperTriangularMatrix );

##
InstallTrueMethod( IsLowerTriangularMatrix, IsHomalgMatrix and IsStrictLowerTriangularMatrix );

##
InstallTrueMethod( IsUpperTriangularMatrix, IsHomalgMatrix and IsUpperStairCaseMatrix );

##
InstallTrueMethod( IsLowerTriangularMatrix, IsHomalgMatrix and IsLowerStairCaseMatrix );

##
InstallTrueMethod( IsTriangularMatrix, IsHomalgMatrix and IsUpperTriangularMatrix );

##
InstallTrueMethod( IsTriangularMatrix, IsHomalgMatrix and IsLowerTriangularMatrix );

##
InstallTrueMethod( IsDiagonalMatrix, IsHomalgMatrix and IsUpperTriangularMatrix and IsLowerTriangularMatrix );

##
InstallTrueMethod( IsDiagonalMatrix, IsHomalgMatrix and IsZero );

##
InstallTrueMethod( IsStrictUpperTriangularMatrix, IsHomalgMatrix and IsZero );

##
InstallTrueMethod( IsStrictLowerTriangularMatrix, IsHomalgMatrix and IsZero );

##
InstallTrueMethod( IsDiagonalMatrix, IsHomalgMatrix and IsIdentityMatrix );

##
InstallTrueMethod( IsZero, IsHomalgMatrix and IsStrictUpperTriangularMatrix and IsStrictLowerTriangularMatrix );

## from HomalgMap.gi

##
InstallMethod( StackMaps,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep and IsHomalgLeftObjectOrMorphismOfLeftObjects,
          IsMapOfFinitelyGeneratedModulesRep and IsHomalgLeftObjectOrMorphismOfLeftObjects ],
        
  function( phi, psi )
    local T, phi_psi, SpS, p;
    
    T := Range( phi );
    
    if not IsIdenticalObj( T, Range( psi ) ) then
        Error( "the two morphisms must have identical target modules\n" );
    fi;
    
    phi_psi := UnionOfRows( MatrixOfMap( phi ), MatrixOfMap( psi ) );
    
    SpS := Source( phi ) + Source( psi );
    
    ## get the position of the set of relations immediately after creating SpS;
    p := Genesis( SpS ).("PositionOfTheDefaultSetOfRelationsOfTheOutput");
    
    phi_psi := HomalgMap( phi_psi, [ SpS, p ], T );
    
    if HasIsEpimorphism( phi ) and IsEpimorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsEpimorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsEpimorphism( psi ) and IsEpimorphism( psi ) then
        SetIsEpimorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsMorphism( phi_psi, true );
    fi;
    
    return phi_psi;
    
end );

##
InstallMethod( StackMaps,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep and IsHomalgRightObjectOrMorphismOfRightObjects,
          IsMapOfFinitelyGeneratedModulesRep and IsHomalgRightObjectOrMorphismOfRightObjects ],
        
  function( phi, psi )
    local T, phi_psi, SpS, p;
    
    T := Range( phi );
    
    if not IsIdenticalObj( T, Range( psi ) ) then
        Error( "the two morphisms must have identical target modules\n" );
    fi;
    
    phi_psi := UnionOfColumns( MatrixOfMap( phi ), MatrixOfMap( psi ) );
    
    SpS := Source( phi ) + Source( psi );
    
    ## get the position of the set of relations immediately after creating SpS;
    p := Genesis( SpS ).("PositionOfTheDefaultSetOfRelationsOfTheOutput");
    
    phi_psi := HomalgMap( phi_psi, [ SpS, p ], T );
    
    if HasIsEpimorphism( phi ) and IsEpimorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsEpimorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsEpimorphism( psi ) and IsEpimorphism( psi ) then
        SetIsEpimorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsMorphism( phi_psi, true );
    fi;
    
    return phi_psi;
    
end );

##
InstallMethod( AugmentMaps,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep and IsHomalgLeftObjectOrMorphismOfLeftObjects,
          IsMapOfFinitelyGeneratedModulesRep and IsHomalgLeftObjectOrMorphismOfLeftObjects ],
        
  function( phi, psi )
    local S, phi_psi, TpT, p;
    
    S := Source( phi );
    
    if not IsIdenticalObj( S, Source( psi ) ) then
        Error( "the two morphisms must have identical source modules\n" );
    fi;
    
    phi_psi := UnionOfColumns( MatrixOfMap( phi ), MatrixOfMap( psi ) );
    
    TpT := Range( phi ) + Range( psi );
    
    ## get the position of the set of relations immediately after creating TpT;
    p := Genesis( TpT ).("PositionOfTheDefaultSetOfRelationsOfTheOutput");
    
    phi_psi := HomalgMap( phi_psi, S, [ TpT, p ] );
    
    if HasIsMonomorphism( phi ) and IsMonomorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsMonomorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsMonomorphism( psi ) and IsMonomorphism( psi ) then
        SetIsMonomorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsMorphism( phi_psi, true );
    fi;
    
    return phi_psi;
    
end );

##
InstallMethod( AugmentMaps,
        "of two homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep and IsHomalgRightObjectOrMorphismOfRightObjects,
          IsMapOfFinitelyGeneratedModulesRep and IsHomalgRightObjectOrMorphismOfRightObjects ],
        
  function( phi, psi )
    local S, phi_psi, TpT, p;
    
    S := Source( phi );
    
    if not IsIdenticalObj( S, Source( psi ) ) then
        Error( "the two morphisms must have identical source modules\n" );
    fi;
    
    phi_psi := UnionOfRows( MatrixOfMap( phi ), MatrixOfMap( psi ) );
    
    TpT := Range( phi ) + Range( psi );
    
    ## get the position of the set of relations immediately after creating TpT;
    p := Genesis( TpT ).("PositionOfTheDefaultSetOfRelationsOfTheOutput");
    
    phi_psi := HomalgMap( phi_psi, S, [ TpT, p ] );
    
    if HasIsMonomorphism( phi ) and IsMonomorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsMonomorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsMonomorphism( psi ) and IsMonomorphism( psi ) then
        SetIsMonomorphism( phi_psi, true );
    elif HasIsMorphism( phi ) and IsMorphism( phi ) and
       HasIsMorphism( psi ) and IsMorphism( psi ) then
        SetIsMorphism( phi_psi, true );
    fi;
    
    return phi_psi;
    
end );

## from HomalgBicomplex.gi

            morphism_aids := rec( );	## this allows us to view the split monos (for q = 0) as generalized embeddings in the (first) filtration of the double complex (see GrothendieckSpectralSequence)
                morphism_aids.(String(bidegrees_source[2])) := MonoOfLeftSummand( S );
                morphism_aids.(String(bidegrees_source[l])) := MonoOfLeftSummand( S );
            S!.MorphismAidMapsInObjectOfTotalComplex := morphism_aids;
            morphism_aids := rec( );	## this allows us to view the split monos (for q = 0) as generalized embeddings in the (first) filtration of the double complex (see GrothendieckSpectralSequence)
                morphism_aids.(String(bidegrees_target[2])) := MonoOfLeftSummand( T );
                morphism_aids.(String(bidegrees_target[l])) := MonoOfLeftSummand( T );
            T!.MorphismAidMapsInObjectOfTotalComplex := morphism_aids;

## from SpectralSequences.gi

            ## stack all morphism aid maps together
            if HasMorphismAidMap( gen_emb2 ) then
                if IsHomalgMap( monomorphism_aid_map ) then
                    monomorphism_aid_map := StackMaps( monomorphism_aid_map, MorphismAidMap( gen_emb2 ) );
                else
                    monomorphism_aid_map := MorphismAidMap( gen_emb2 );
                fi;
            fi;
           
        ## store the monomorphism_aid_map in all the generalized embeddings
        ## of the second spectral sequence
        if IsHomalgMap( monomorphism_aid_map ) then
            for pq in bidegrees do
                
                q := pq[1];		## we flip p and q of the bicomplex since we take
                p := pq[2];		## the second spectral sequence as our reference
                
                gen_emb2 := grothendieck2.(String([ p, q ]));
                
                RemoveMorphismAidMap( gen_emb2 );
                
                SetMorphismAidMap( gen_emb2, monomorphism_aid_map );
                
            od;
        fi;
        
##
InstallMethod( GrothendieckSpectralSequence,
        "for homalg maps",
        [ IsHomalgFunctorRep, IsHomalgFunctorRep, IsFinitelyPresentedModuleRep ],
        
  function( Functor_F, Functor_G, M )
    local F, G, P, GP, CE, FCE, BC, Tot, H, I_E, tBC, II_E, I_E2, II_E2,
          II_E_infinity, grothendieck, grothendieck1, grothendieck2,
          n, ToTn, bidegrees, l, pq, p, q, tot_embs, gen_emb0,
          gen_emb1, gen_emb2, gen_emb, monomorphism_aid_map, gen_map;
    
    F := OperationOfFunctor( Functor_F );
    G := OperationOfFunctor( Functor_G );
    
    ## a projective resolution of M
    ## (which is an injective resolution in the opposite category)
    P := Resolution( M );
    
    ## apply the inner functor G to the resolution P of M
    GP := G( P );
    
    ## compute the Cartan-Eilenberg resolution of P
    CE := Resolution( GP );
    
    ## apply the outer functor F to the Cartan-Eilenberg resolution
    FCE := F( CE );
    
    ## the associated bicomplex
    BC := HomalgBicomplex( FCE );
    
    ## the associated total complex
    Tot := TotalComplex( BC );
    
    ## the (co)homology graded object of the total complex:
    H := DefectOfExactness( Tot );
    
    ## test for zero defects in H:
    IsZero( H );
    
    ## the spectral sequence associated to BC,
    ## also called the first spectral sequence of the bicomplex BC;
    ## its limit sheet is the second sheet,
    ## where it also becomes intrinsic (in the abelian category)
    I_E := HomalgSpectralSequence( BC );
    
    ## the transposed bicomplex associated to FCE
    tBC := TransposedBicomplex( BC );
    
    ## the spectral sequence associated to tBC,
    ## also called the second spectral sequence of the bicomplex BC;
    ## it becomes intrinsic at the second level R^(-p) F R^q G => L_(p+q) FG
    II_E := HomalgSpectralSequence( 2, tBC );
    
    ## the limit sheet of the first spectral sequence
    I_E2 := CertainSheet( I_E, 2 );
    
    ## the intrinsic sheet of the second spectral sequence
    II_E2 := CertainSheet( II_E, 2 );
    
    ## the limit sheet of the second spectral sequence
    II_E_infinity := HighestLevelSheetInSpectralSequence( II_E );
    
    grothendieck := rec( );
    grothendieck1 := rec( );
    grothendieck2 := rec( );
    
    for n in Filtered( ObjectDegreesOfComplex( Tot ), j -> j >= 0 ) do	## the (co)homologies vanish in negative total degrees
        
        ToTn := CertainObject( Tot, n );
        
        if IsBound( ToTn!.EmbeddingsInObjectOfTotalComplex ) then
            tot_embs := ToTn!.EmbeddingsInObjectOfTotalComplex;
        else
            tot_embs := fail;	## happens at the ends of the total complex
        fi;
        
        gen_emb0 := NaturalGeneralizedEmbedding( CertainObject( H, n ) );
        
        ## for the first spectral sequence I_E
        gen_emb1 := I_E2!.absolute_embeddings.(String([ n, 0 ]));
        
        if tot_embs <> fail then
            gen_emb1 := PreCompose( gen_emb1, tot_embs.(String([ n, 0 ])) );
        fi;
        
        ## this is the isomorphism I_E^{n,0} = H^n( Tot( BC ) )
        gen_emb1 := gen_emb1 / gen_emb0;
        
        ## check assertion
        Assert( 1, IsIsomorphism( gen_emb1 ) );
        
        SetIsIsomorphism( gen_emb1, true );
        
        grothendieck1.(String([ n, 0 ])) := gen_emb1;
        
        ## for the second spectral sequence II_E
        bidegrees := BidegreesOfObjectOfTotalComplex( BC, n );
        
        l := Length( bidegrees );
        
        monomorphism_aid_map := 0;
        
        for pq in bidegrees do
            
            q := pq[1];		## we flip p and q of the bicomplex since we take
            p := pq[2];		## the second spectral sequence as our reference
            
            gen_emb2 := II_E_infinity!.absolute_embeddings.(String([ p, q ]));
            
            if tot_embs <> fail then
                gen_emb2 := PreCompose( gen_emb2, tot_embs.(String([ q, p ])) );	## note the flip [ q, p ]
            fi;
            
            ## this is the generalized embedding of II_E^{p,q} into H^{p+q}( Tot( BC ) )
            gen_emb2 := gen_emb2 / gen_emb0;
            
            SetIsGeneralizedMonomorphism( gen_emb2, true );
            
            ## at least the highest is a monomorphism
            IsMonomorphism( gen_emb2 );
            
            grothendieck2.(String([ p, q ])) := gen_emb2;
            
        od;
        
        monomorphism_aid_map := 0;
        
        for pq in Reversed( bidegrees ) do		## note the "Reversed"
            
            q := pq[1];		## we flip p and q of the bicomplex since we take
            p := pq[2];		## the second spectral sequence as our reference
            
            gen_emb := grothendieck2.(String([ p, q ])) / grothendieck1.(String([ n, 0 ]));
            
            ## start to make the gen_emb's the generalized embeddings
            ## of the filtration induced by the second spectral sequence
            gen_map := HomalgMap( MatrixOfMap( gen_emb ), "free", Range( gen_emb ) );
            
            if IsHomalgMap( monomorphism_aid_map ) then
                SetMorphismAidMap( gen_emb, monomorphism_aid_map );
                monomorphism_aid_map := StackMaps( monomorphism_aid_map, gen_map );
            else
                monomorphism_aid_map := gen_map;
            fi;
            
            ## IsIsomorphism would first checks IsEpimorphism and if false
            ## it would simply return false without cheching IsMonomorphism
            IsEpimorphism( gen_emb );
            IsMonomorphism( gen_emb );
            
            ## at least the lowest one is a generalized isomrphism
            IsGeneralizedIsomorphism( gen_emb );
            
            ## check assertion
            Assert( 1, IsGeneralizedMonomorphism( gen_emb ) );
            
            SetIsGeneralizedMonomorphism( gen_emb, true );
            
            grothendieck.(String([ p, q ])) := gen_emb;
            
        od;
        
        ## the lowest one is a generalized isomorphism
        p := bidegrees[1][2];
        q := bidegrees[1][1];
        
        ## check assertion
        Assert( 1, IsGeneralizedIsomorphism( grothendieck.(String([ p, q ])) ) );
        
        SetIsGeneralizedIsomorphism( grothendieck.(String([ p, q ])), true );
        
        ## the higest one is a monomorphism
        p := bidegrees[l][2];
        q := bidegrees[l][1];
        
        ## check assertion
        Assert( 1, IsMonomorphism( grothendieck.(String([ p, q ])) ) );
        
        SetIsMonomorphism( grothendieck.(String([ p, q ])), true );
        
    od;
    
    ## first enrich I_E
    SetGeneralizedEmbeddingsInTotalObjects( I_E, grothendieck1 );
    
    ## now its time to enrich II_E
    SetGeneralizedEmbeddingsInTotalObjects( II_E, grothendieck2 );
    
    ## even with
    II_E!.FirstSpectralSequence := I_E;
    
    ## and finally
    II_E!.GeneralizedEmbeddingsInStableSecondSheetOfFirstSpectralSequence := grothendieck;
    
    return II_E;
    
end );

## from HomalgMap.gd/gi

DeclareOperation( "RemoveMorphismAidMap",
        [ IsHomalgMap ] );

DeclareOperation( "ReplaceMorphismAidMap",
        [ IsHomalgMap, IsObject ] );

##
InstallMethod( RemoveMorphismAidMap,
        "for homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep ],
        
  function( phi )
    
    ResetFilterObj( phi, MorphismAidMap );
    Unbind( phi!.MorphismAidMap );
    
end );

## never use this operation unless you know what you are doing
## (together with the caching of the functors PostDivide and Compose
##  it could lead to wrong results)
InstallMethod( ReplaceMorphismAidMap,
        "for homalg maps",
        [ IsMapOfFinitelyGeneratedModulesRep, IsObject ],
        
  function( phi, morphism_aid_map )
    local morphism_aid_map1;
    
    if IsHomalgMap( morphism_aid_map ) then
        
        if not IsIdenticalObj( Range( phi ), Range( morphism_aid_map ) ) then
            Error( "the targets of the two morphisms must coincide\n" );
        fi;
	
        ## we don't need the source of the morphism aid map
        morphism_aid_map1 := OnAFreeSource( morphism_aid_map );
        
        ## first clean up
        RemoveMorphismAidMap( phi );
        
        ## a generalized embedding may now become
	## only a generalized homomorphism
        homalgResetFilters( phi );
        
        SetMorphismAidMap( phi, morphism_aid_map1 );
        
    fi;
    
end );

## from HomalgFiltration.gi

        ## (this also avoids an error that occurs in CompleteImageSquare below
        ##  this pops up during the execution of A3_Purity.g)
        RemoveMorphismAidMap( gen_emb );

## from SpectralSequence.gi

        ## this is necessary for handling not only homological
        ## but also cohomological spectral sequences
        if IsSpectralSequenceOfFinitelyPresentedObjectsRep( II_E ) then
            bidegrees := Reversed( bidegrees );			## note the "Reversed"
        fi;
        
## from HomalgBigradedObject.gi

          Tot, n, Tot_s, Tot_t, bidegrees_s, bidegrees_t,
          tot_embs, tot_prjs;
        if cpx then
            p_degrees := bidegrees[1]{[ r + 1 .. lp ]};
            q_degrees := bidegrees[2]{[ 1 .. lq - ( r - 1 ) ]};
            for p in p_degrees do
                for q in q_degrees do
                    source := CertainObject( Er, [ p, q ] );
                    target := CertainObject( Er, [ p, q ] + bidegree );
                    if not ForAny( [ source, target ], IsZero ) then
                        mor_h := List( [ 0 .. r - 1 ], i -> CertainHorizontalMorphism( B, [ p - i, q + i ] ) );
                        mor_v := List( [ 1 .. r - 1 ], i -> CertainVerticalMorphism( B, [ p - i, q + i ] ) );
                        if ForAny( mor_h, IsZero ) or ForAny( mor_v, IsZero ) then
                            mor := TheZeroMap( source, target );
                        else
                            emb_source := Er!.absolute_embeddings.(String( [ p, q ] ));
                            emb_target := Er!.absolute_embeddings.(String( [ p, q ] + bidegree ));
                            if r > 1 then
                                ## the associated total complex
                                Tot := TotalComplex( B );
                                
                                n := p + q;
                                
                                ## the n-th total object
                                Tot_s := CertainObject( Tot, n );
                                
                                ## the (n-1)-st total object
                                Tot_t := CertainObject( Tot, n - 1 );
                                
                                ## the bidegrees of total degree n
                                bidegrees_s := BidegreesOfObjectOfTotalComplex( B, n );
                                
                                ## the bidegrees of total degree n - 1
                                bidegrees_t := BidegreesOfObjectOfTotalComplex( B, n - 1 );
                                
                                ## the embeddings from B_{p,q} -> Tot_n
                                tot_embs := EmbeddingsInCoproductObject( Tot_s, bidegrees_s );
                                
                                ## the projections from Tot_n -> B_{p,q}
                                tot_prjs := ProjectionsFromProductObject( Tot_t, bidegrees_t );
                                
                                if tot_embs <> fail then
                                    emb_source := PreCompose( emb_source, tot_embs.(String([ p, q ])) );
                                fi;
                                
                                mor := PreCompose( emb_source, MorphismOfTotalComplex( B, n ) );
                                
                                if tot_prjs <> fail then
                                    mor := PreCompose( mor, tot_prjs.(String([ p, q ] + bidegree )) );
                                fi;
                                
                            else
                                mor := PreCompose( emb_source, mor_h[1] );
                            fi;
                            mor := mor / emb_target;
                        fi;
                        Assert( 1, IsMorphism( mor ) );
                        SetIsMorphism( mor, true );
                        Er!.(String( [ p, q ] )) := mor;
                    fi;
                od;
            od;
        else
            p_degrees := bidegrees[1]{[ 1 .. lp - r ]};
            q_degrees := bidegrees[2]{[ r .. lq ]};
            for p in p_degrees do
                for q in q_degrees do
                    source := CertainObject( Er, [ p, q ] );
                    target := CertainObject( Er, [ p, q ] + bidegree );
                    if not ForAny( [ source, target ], IsZero ) then
                        mor_h := List( [ 0 .. r - 1 ], i -> CertainHorizontalMorphism( B, [ p + i, q - i ] ) );
                        mor_v := List( [ 1 .. r - 1 ], i -> CertainVerticalMorphism( B, [ p + i, q - i ] ) );
                        if ForAny( mor_h, IsZero ) or ForAny( mor_v, IsZero ) then
                            mor := TheZeroMap( source, target );
                        else
                            emb_source := Er!.absolute_embeddings.(String( [ p, q ] ));
                            emb_target := Er!.absolute_embeddings.(String( [ p, q ] + bidegree ));
                            if r > 1 then
                                ## the associated total complex
                                Tot := TotalComplex( B );
                                
                                n := p + q;
                                
                                ## the n-th total object
                                Tot_s := CertainObject( Tot, n );
                                
                                ## the (n+1)-st total object
                                Tot_t := CertainObject( Tot, n + 1 );
                                
                                ## the bidegrees of total degree n
                                bidegrees_s := BidegreesOfObjectOfTotalComplex( B, n );
                                
                                ## the bidegrees of total degree n + 1
                                bidegrees_t := BidegreesOfObjectOfTotalComplex( B, n + 1 );
                                
                                ## the embeddings from B^{p,q} -> Tot^n
                                tot_embs := EmbeddingsInCoproductObject( Tot_s, bidegrees_s );
                                
                                ## the projections from Tot^n -> B^{p,q}
                                tot_prjs := ProjectionsFromProductObject( Tot_t, bidegrees_t );
                                
                                if tot_embs <> fail then
                                    emb_source := PreCompose( emb_source, tot_embs.(String([ p, q ])) );
                                fi;
                                
                                mor := PreCompose( emb_source, MorphismOfTotalComplex( B, n ) );
                                
                                if tot_prjs <> fail then
                                    mor := PreCompose( mor, tot_prjs.(String([ p, q ] + bidegree )) );
                                fi;
                                
                            else
                                mor := PreCompose( emb_source, mor_h[1] );
                            fi;
                            mor := mor / emb_target;
                        fi;
                        Assert( 1, IsMorphism( mor ) );
                        SetIsMorphism( mor, true );
                        Er!.(String( [ p, q ] )) := mor;
                    fi;
                od;
            od;
        fi;
