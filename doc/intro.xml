<?xml version="1.0" encoding="UTF-8"?>

<!-- 

  intro.xml            homalg package documentation            Mohamed Barakat

         Copyright (C) 2007-2009, Mohamed Barakat, RWTH-Aachen

This chapter gives a short introduction and explains the philosophy
behind the package.

-->

<Chapter Label="intro">
<Heading>Introduction</Heading>

<Section Label="homalg-vs-homalg">
<Heading>What is the role of the &homalg; package in the &homalg; project?</Heading>

<Subsection Label="philosophy">
<Heading>Philosophy</Heading>

The package &homalg; is meant to be the first part of a continuously
growing <Alt Only="Text">open source</Alt>
<Alt Not="Text"><URL Text="open
source">http://www.opensource.org/</URL></Alt> multi volume book about
<Alt Only="Text">homological</Alt><Alt Not="Text">
<URL Text="homological">http://en.wikipedia.org/wiki/Homological_algebra</URL></Alt>
and <Alt Only="Text">homotopical
algebra</Alt><Alt Not="Text"><URL Text="homotopical
algebra">http://en.wikipedia.org/wiki/Homotopical_algebra</URL></Alt>.
&homalg; is an attempt to translate as much as possible of homological
algebra, as can be found in books like <Cite Key="ce"/>,
<Cite Key="ML"/>, <Cite Key="HS"/>, <Cite Key="rot"/>,
<Cite Key="weihom"/>, and <Cite Key="GM"/>, into a language that a
computer can directly understand. But just like the aforementioned
books, &homalg; should, to a great extent, be readable by a
mathematician, even without deep programming knowledge. For the
reasons mentioned in (&see; Appendix <Ref Sect="WhyGAP4" Text="Why GAP4?"/>)
&GAP4; was chosen as the language of &homalg;.

</Subsection>

<Subsection Label="homalg-provides">
<Heading>&homalg; provides ...</Heading>

The package &homalg; is the foundational part of the project. It
provides procedures to construct basic objects in homological algebra:
<List>
  <Item>rings</Item>
  <Item>ring maps</Item>
  <Item>matrices</Item>
  <Item>modules (generators, relations)</Item>
  <Item>maps</Item>
  <Item>filtrations</Item>
  <Item>complexes (of modules and of complexes)</Item>
  <Item>chain maps</Item>
  <Item>bicomplexes</Item>
  <Item>bigraded (differential) objects</Item>
  <Item>spectral sequences</Item>
  <Item>functors</Item>
</List>
Beside these so-called constructors &homalg;
provides <Alt Only="HTML"><Ref Text="operations"
Sect="Operations and Methods" BookName="Prg Tutorial"/></Alt>
<Alt Not="HTML"><E>operations</E></Alt> to perform computations with
these objects. The list of operations includes:
<List>
  <Item>resolution of modules</Item>
  <Item>computation of subfactor modules</Item>
  <Item>applying functors (like <C>Ext</C>, <C>Tor</C>, ...) to modules,
    maps, complexes and chain maps</Item>
  <Item>derivation and composition of functors</Item>
  <Item>horse shoe resolution of short exact sequences of
    modules</Item>
  <Item>connecting homomorphisms and long exact sequences</Item>
  <Item>Cartan-Eilenberg resolution of complexes</Item>
  <Item>hyper (co)homology</Item>
  <Item>spectral sequences of bicomplexes</Item>
  <Item>the Grothendieck spectral sequences associated to two
    composable functors</Item>
  <Item>test if a module is torsion-free, reflexive, projective,
    stably free, free, pure</Item>
  <Item>determine the rank, codimension, projective dimension, degree
    of torsion-freeness, and codegree of purity of a module</Item>
</List>

Using the philosophy of &GAP4;, one or
more <Alt Only="HTML"><Ref Text="methods" Sect="Operations and
Methods" BookName="Prg Tutorial"/></Alt> <Alt Not="HTML">methods</Alt>
are
<Alt Only="HTML"><Ref Text="installed" Sect="Method Installation"
BookName="Prg Tutorial"/></Alt>
<Alt Not="HTML"><E>installed</E></Alt> for each operation, depending
on <Alt Only="HTML"><Ref Text="properties" Sect="Properties"
BookName="Tutorial"/></Alt> <Alt Not="HTML"><E>properties</E></Alt>
and <Alt Only="HTML"><Ref Text="attributes" Sect="attributes"
BookName="Tutorial"/></Alt> <Alt Not="HTML"><E>attributes</E></Alt> of
these objects. These properties and attributes can themselves be
computed by methods installed for this purpose.

</Subsection>

<Subsection Label="homalg-delegates">
<Heading>&homalg; delegates ...</Heading>

The package &homalg; <E>delegates</E> <E>all</E> matrix operations as
it treats matrices and their rings as <E>black boxes</E>. &homalg;
comes with a single predefined class of rings and a single predefined
class of matrices over these rings -- the so-called internal matrices
(&see; <Ref Label="IsHomalgInternalMatrixRep"/>) over so-called
internal rings (&see; <Ref Label="IsHomalgInternalRingRep"/>). An
internal matrix (resp. ring) is simply a wrapper containing a
&GAP;-builtin matrix (resp. ring). &homalg; allows other packages to
define further classes or extend existing classes of rings and
matrices <E>together</E> with their operations. For example:
<List>
  <Item>The &homalg; subpackage &ResidueClassRingForHomalg; (&see;
  Appendix <Ref Chap="ResidueClassRingForHomalg"/>) defines the
  classes of residue class rings, residue class ring elements, and
  matrices over residue class rings. Such a matrix is defined by a
  matrix over the ambient ring which is nevertheless interpreted
  modulo the ring relations, i.e. modulo the generators of the
  defining ideal. </Item>
  <Item>The package &GaussForHomalg; extends the class of internal
  matrices enabling it to wrap sparse matrices provided by the
  package &Gauss;. &GaussForHomalg; delegates the essential part of
  the matrix creation and all matrix operations to &Gauss;.</Item>
  <Item>The package &HomalgToCAS; (&see; Appendix <Ref Sect="homalg-Project"/>) defines the classes of
  so-called external rings and matrices and the package
  &RingsForHomalg; delegates the essential part of the matrix creation
  and all matrix operations to external computer algebra systems like
  &Singular;, &Macaulay2;, &Sage;, &Macaulay2;, &MAGMA;, &Maple;, ... . The package
  &homalg; accesses external matrices via pointers. The pointer of an
  external matrix is simply its name in the external
  system. &HomalgToCAS; chooses these names.</Item>
  <Item>The package &LocalizeRingForHomalg; defines the classes of
  local(ized) rings, local ring elements, and local matrices. A
  &homalg; local matrix contains a &homalg; matrix as a numerator and
  an element of the global ring as a denominator.</Item>
</List>
  
<P/>

The matrix operations are divided into two classes called <Q>Tools</Q>
and <Q>Basic</Q>. The <Q>Tools</Q> operations include addition,
subtraction, multiplication, extracting certain rows or columns,
stacking, and augmenting matrices (&see; Appendix
<Ref Chap="Tool_Operations"/>).  The <Q>Basic</Q> operations include
the two basic operations in linear algebra needed to solve an
inhomogeneous linear system <M>XA=B</M> with coefficients in a not
necessarily commutative ring <M>R</M> (&see; Appendix
<Ref Chap="Basic_Operations"/>):
<List>
  <Item>Effectively reducing <M>B</M> modulo <M>A</M>,
    i.e. effectively deciding if a row (or a set of rows) <M>B</M>
    lies in the <M>R</M>-span of the rows of the
    matrix <M>A</M>.</Item>
  <Item>Computing an <M>R</M>-generating set of row syzygies
    (=<M>R</M>-relations among the rows) of <M>A</M>, i.e. computing
    an <M>R</M>-generating set of the left kernel of <M>A</M>. This
    generating set is then given as the rows of a matrix <M>Y</M>
    and <M>YA=0</M>.</Item>
</List>
The first operation is nothing but deciding the solvability of the
inhomogeneous system <M>XA=B</M> and if solvable to compute a
particular solution <M>X</M>, while the second is to compute an
<M>R</M>-generating set for the homogeneous solution space, i.e. the
solution space of the homogeneous system <M>YA=0</M> (&see;
<Ref Label="SufficientSupport" Text="Rings supported in a sufficient
way"/>). The above is of course also valid for the column convention.

</Subsection>

<Subsection Label="SufficientSupport">
<Heading>Rings supported in a sufficient way</Heading>

Through out this manual the following terminology is used.  We say
that a computer algebra system <Q>sufficiently supports</Q> a
ring <M>R</M>, if it contains procedures to effectively solve
one-sided inhomogeneous linear systems <M>XA=B</M> and <M>AX=B</M>
with coefficients over <M>R</M> (&see; <Ref Label="homalg-limitation"
Text="Principal limitation"/>).

</Subsection>

<Subsection Label="homalg-limitation">
<Heading>Principal limitation</Heading>

Note that the solution space of the one-sided finite dimensional
system <M>YA=0</M> (resp. <M>AY=0</M>) over a left (resp. right)
noetherian ring <M>R</M> is a finitely generated left
(resp. right) <M>R</M>-module, even if <M>R</M> is not
commutative. The solution space of the linear system <M>X_1 A_1 + A_2
X_2 + A_3 X_3 A_4=0</M> is in general not an <M>R</M>-module, and
worse, in general not finitely generated over the center
of <M>R</M>. &homalg; can only handle homological problems that lead
to <E>one sided</E> <E>finite dimensional</E> homogeneous or
inhomogeneous systems over the underlying ring <M>R</M>. Such problems
are called problems of <E>finite type</E> over <M>R</M>. Typically,
the computation of <C>Hom</C><M>(M,N)</M> of two (even) finitely
generated modules over a <E>non</E>commutative ring <M>R</M> is
generally <E>not</E> of finite type over <M>R</M>, unless at least one
of the two modules is an <M>R</M>-bimodule. Also note that over a
commutative ring any linear system can be easily brought to a
one-sided form. For more details see <Cite Key="BR"/>. <P/>

</Subsection>

<Subsection Label="black box">
<Heading>The black box concept</Heading>

<P/>

Now we address the following concerns: Wouldn't the idea of using
algorithms like the Gröbnerbasis algorithm(s) as a black box (&see;
<Ref Sect="homalg-delegates" Text="homalg delegates ..."/>) contradict
the following facts?
<List> 
  <Item> It is known that an efficient Gröbnerbasis algorithm depends
    on the ring <M>R</M> under consideration. For example the
    implementation of the algorithm depends on the ground ring (or
    field) <M>k</M>.</Item>
  <Item> Often enough highly specialized implementations are used to
    address specific types of linear systems of equations (occuring in
    specific homological problems) in order to increase the speed or
    reduce the space needed for the computations.</Item>
</List>

The following should clarify the above concerns.
<List>
  <Item> Since each ring comes with its own black box, the first point
    is automatically resolved.</Item>
  <Item> Allow the black box coming with each ring to contain the
    different available implementations and make them accessible to
    &homalg; via standarized names, independent of the computer
    algebra system used to perform computations.</Item>
</List>

See also <Ref Sect="Why ZZ"/>.

</Subsection>

<Subsection Label="homalg-dict">
<Heading>&homalg;'s dictionaries (technical)</Heading>

&homalg; uses the so-called <C>homalgTable</C>, which is stored in the
ring, to know how to delegate the necessary matrix operations.
I.e. the <C>homalgTable</C> serves as a small dictionary that enables
&homalg; to speak (as much as needed of) the language of the computer
algebra system which hosts the ring and the matrices. The &GAP;
internal ring of integers is the only ring which &homalg; endows with
a <C>homalgTable</C>. Other packages like &GaussForHomalg; and
&RingsForHomalg; provide dictionaries for further rings. While
&GaussForHomalg; defines internal rings and matrices, the package
&RingsForHomalg; enables defining external rings and matrices in a
wide range of (external) computer algebra systems (&Singular;, &Sage;,
&Macaulay2;, &MAGMA;, &Maple;) by providing appropriate dictionaries. <P/>

Since these dictionaries are all what is needed to handle matrix
operations, &homalg; does not distinguish between handling internal
and handling external matrices. Even the physical communication with
the external systems is not at all a concern of &homalg;. This is the
job of the package &IO_ForHomalg;, which is based on the powerful &IO;
package of Max Neunhöffer. Furthermore, for all structures beyond
matrices (from relations, generators, and modules, to functors and
spectral sequences) &homalg; no longer distinguishes between internal
and external. <P/>

</Subsection>

<Subsection Label="outsource">
<Heading>The advantages of the outsourcing concept</Heading>

Linking different systems to achieve one task is a highly attractive
idea, especially if it helps to avoid reinventing wheels over and over
again. This was essential for &homalg;, since &Singular; and &MAGMA;
provide the fastest and most advanced Gröbner basis algorithms, while
&GAP4; is by far the most convenient programming language to realize
complex mathematical structures (&see; Appendix <Ref Sect="WhyGAP4"
Text="Why GAP4?"/>).  Second, the implementation of the homological
constructions is automatically universal, since it is independent of
where the matrices reside and how the several matrix operations are
realized. In particular, &homalg; will always be able to use the
system with the fastest Gröbner basis implementation. In this respect
is &homalg; and all packages that build upon it future proof.

</Subsection>

<Subsection Label="also-special">
<Heading>Does this mean that &homalg; has only algorithms for the generic case?</Heading>

No, on the contrary. There are a lot of specialized algorithms
installed in &homalg;. These algorithms are based on properties and
attributes that -- thanks to &GAP4; -- &homalg; objects can carry
(&see; Appendix <Ref Label="Objectify"/>): Not only can &homalg; take
the special nature of the underlying ring into account, it also deals
with modules, complexes, ... depending on their special
properties. Still, these special algorithms, like all algorithms in
&homalg;, are independent of the computer algebra system which hosts
the matrices and which will perform the several matrix operations.

</Subsection>

<Subsection Label="least-communication">
<Heading>The principle of least communication (technical)</Heading>

Linking different systems can also be highly problematic. The
following two points are often among the major sources of
difficulties:
<List>
  <Item>Different systems use different languages:<Br/> It takes a
    huge amount of time and effort to teach systems the dialects of
    each others. These dialects are also rarely fixed forever, and
    might very well be subject to slight modifications. So the larger
    the dictionary, the more difficult is its maintenance.</Item>
  <Item>Data has to be transferred from one system to another:<Br/>
    Even if there is a unified data format, transferring data between
    systems can lead to performance losses, especially when a big
    amount of data has to be transferred.</Item>
</List>

Solving these two difficulties is an important part of &homalg;'s
design. &homalg; splits homological computations into two parts. The
matrices reside in a system which provides fast matrix operations
(addition, multiplication, bases and normal form computations), while
the higher structures (modules, maps, complexes, chain maps, spectral
sequences, functors, ...) with their properties, attributes, and
algorithms live in &GAP4;, as the system where one can easily create
such complex structures and handle all their logical dependencies.
With this split there is no need to transfer each sort of data outside
of its system. The remaining communication between &GAP4; and the
system hosting the matrices gets along with a tiny dictionary.
Moreover, &GAP4;, as it manages and delegates all computations, also
manages the whole data flow, while the other system does not even
recognize that it is part of a bidirectional communication. <P/>

The existence of such a clear cut is certainly to some extent due to
the special nature of homological computations.

</Subsection>

<Subsection Label="build">
<Heading>Building upon the &homalg; package</Heading>

As mentioned above, the package &homalg; should only be the first and
foundational part of the &homalg; project. On the one hand it is
designed independently of the details of the different matrix
operations, which other packages are meant to provide. Typically,
these packages (like &RingsForHomalg;) heavily rely on existing, well
tested, and optimized systems like &Singular;, &Macaulay2;, or
&MAGMA;. On the other hand other packages can be built upon or extend
the &homalg; package in different ways:
<List>
  <Item>add constructors (sheaves, schemes, simplicial sets, ...)</Item>
  <Item>add methods for basic operation (Yoneda products, Massey
    products, Steenrod operations, ...)</Item>
  <Item>add methods to compute sheaf cohomology, local cohomology,
    Hochschild (co)homology, cyclic (co)homology...</Item>
  <Item>provide algorithms for holonomic <M>D</M>-modules based on the
    restriction algorithm: localization, computing tensor
    products, <C>Hom</C>, <C>Ext</C>, de Rham cohomology, ...</Item>
  <Item>support change of rings, Lyndon/Hochschild-Serre spectral
    sequence, base change spectral sequences, ...</Item>
  <Item>support perturbation techniques, Serre and Eilenberg-Moore
    spectral sequence of simplicial spaces of infinite type,
    ...</Item>
  <Item>...</Item>
</List>

The project will remain open and contributions are highly welcome. The
different packages will be attributed to their respective authors. The
whole project will be attributed to the "&homalg; team", i.e. the
authors and contributers of all packages in the project.

</Subsection>

<Subsection Label="FAQ">
<Heading>Frequently asked questions</Heading>

<List>
  <Item><B>Q</B>: Does outsourcing the matrices mean that &homalg; is
    able to compute spectral sequences, for example, without ever
    seeing the matrices involved in the computation?<Br/><Br/> A:
    Yes.</Item>
  <Item><B>Q</B>: Can &homalg; profit from the implementation of
    homological constructions like <C>Hom</C>, <C>Ext</C>, ... in
    &Singular;?<Br/><Br/> A: No. This is for a lot of reasons
    incompatible with the <Alt Only="HTML"><Ref Text="idea and design" Label="intro"/></Alt>
    <Alt Not="HTML">idea and design (&see; <Ref Label="intro"/>)</Alt>
    of &homalg;.</Item>
  <Item><B>Q</B>: Are the external systems involved in the higher
    algorithms?<Br/><Br/> A: No. They host all the matrices and do all
    matrix operations delegated to them without knowing what for. The
    meaning of the matrices and their logical interrelation is only
    known to &GAP4;.</Item>
  <Item><B>Q</B>: Do developers of packages building upon &homalg;
    need to know anything about the communication with the external
    systems?<Br/><Br/> A: No, unless they want to use more features of
    the external systems than those reflected by &homalg;. For this
    purpose, developers can use the unified communication interface
    provideb by &HomalgToCAS;. This is the interface used by
    &homalg;.</Item>
</List>

</Subsection>

</Section>

<Section Label="overview">
<Heading>This manual</Heading>

Chapter <Ref Chap="install"/> describes the installation of this
package, while Chapter <Ref Chap="QuickStart"/> provides a short quick
guide to build your first own example, using the package
&ExamplesForHomalg;. The remaining chapters are each devoted to one of
the &homalg; objects (&see; <Ref Label="homalg-provides"/>) with its
constructors, properties, attributes, and operations.

<!--
Finally, Chapter <Ref Chap="examples"/> shows some instructive
examples for the usage of this package.
-->

</Section>

<!-- ############################################################ -->

</Chapter>

<!--  LocalWords:  ExamplesForHomalg
 -->
